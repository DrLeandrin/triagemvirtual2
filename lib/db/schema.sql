-- Triagem Virtual Database Schema
-- Run this script in Supabase SQL Editor after project creation
-- After running, enable Custom Access Token Hook in Dashboard:
-- Authentication -> Hooks -> Custom Access Token Hook -> select public.custom_access_token_hook

-- Create app_role enum type
create type public.app_role as enum ('patient', 'doctor', 'admin');

-- Create user_roles table for RBAC
create table public.user_roles (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  role app_role not null,
  unique(user_id, role)
);

-- Create custom access token hook function
-- This function injects the user's role into the JWT claims
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
  declare
    claims jsonb;
    user_role public.app_role;
  begin
    select role into user_role from public.user_roles
    where user_id = (event->>'user_id')::uuid;

    claims := event->'claims';

    if user_role is not null then
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;

    event := jsonb_set(event, '{claims}', claims);

    return event;
  end;
$$;

-- Grant permissions for auth hook
grant usage on schema public to supabase_auth_admin;

grant execute on function public.custom_access_token_hook to supabase_auth_admin;

revoke execute on function public.custom_access_token_hook from authenticated, anon, public;

grant all on table public.user_roles to supabase_auth_admin;

revoke all on table public.user_roles from anon, public;

-- Authenticated users need select/insert for signup flow
grant select, insert on table public.user_roles to authenticated;

-- Enable RLS on user_roles
alter table public.user_roles enable row level security;

-- Policy: Allow supabase_auth_admin to select from user_roles
create policy "Allow auth admin to read user roles"
  on public.user_roles
  for select
  to supabase_auth_admin
  using (true);

-- Policy: Authenticated users can insert their own role (needed during signup)
create policy "Users can insert own role"
  on public.user_roles
  for insert
  to authenticated
  with check (auth.uid() = user_id);

-- Policy: Authenticated users can read their own role
create policy "Users can read own role"
  on public.user_roles
  for select
  to authenticated
  using (auth.uid() = user_id);

-- Create authorize helper function
-- This function checks if the current user has the requested role
create or replace function public.authorize(requested_role app_role)
returns boolean
language plpgsql
stable
security definer
set search_path = ''
as $$
  declare
    user_role public.app_role;
  begin
    select (auth.jwt() ->> 'user_role')::public.app_role into user_role;

    return user_role = requested_role;
  end;
$$;

-- Create patients table
create table public.patients (
  id uuid default gen_random_uuid() primary key,
  user_id uuid references auth.users on delete cascade not null unique,
  full_name text not null,
  cpf text unique not null,
  birth_date date,
  phone text,
  created_at timestamptz default now() not null
);

-- Enable RLS on patients
alter table public.patients enable row level security;

-- Patients can view/edit their own records
create policy "Patients can view own record"
  on public.patients
  for select
  using (auth.uid() = user_id);

create policy "Patients can insert own record"
  on public.patients
  for insert
  with check (auth.uid() = user_id);

create policy "Patients can update own record"
  on public.patients
  for update
  using (auth.uid() = user_id);

-- Doctors can view all patients
create policy "Doctors can view all patients"
  on public.patients
  for select
  using (authorize('doctor'));

-- Create doctors table
create table public.doctors (
  id uuid default gen_random_uuid() primary key,
  user_id uuid references auth.users on delete cascade not null unique,
  full_name text not null,
  crm text unique not null,
  specialty text,
  created_at timestamptz default now() not null
);

-- Enable RLS on doctors
alter table public.doctors enable row level security;

-- Doctors can view each other
create policy "Doctors can view other doctors"
  on public.doctors
  for select
  using (authorize('doctor'));

-- Doctors can insert/update their own record
create policy "Doctors can insert own record"
  on public.doctors
  for insert
  with check (auth.uid() = user_id);

create policy "Doctors can update own record"
  on public.doctors
  for update
  using (auth.uid() = user_id);

-- Create consultation_status enum
create type public.consultation_status as enum ('waiting', 'in_review', 'contacted', 'completed');

-- Create urgency_level enum
create type public.urgency_level as enum ('emergency', 'urgent', 'less_urgent', 'non_urgent');

-- Create consultations table
create table public.consultations (
  id uuid default gen_random_uuid() primary key,
  patient_id uuid references public.patients(id) not null,
  doctor_id uuid references public.doctors(id),
  status consultation_status default 'waiting' not null,
  transcript text,
  summary jsonb,
  urgency urgency_level,
  hypotheses jsonb,
  created_at timestamptz default now() not null,
  updated_at timestamptz default now() not null
);

-- Enable RLS on consultations
alter table public.consultations enable row level security;

-- Patients can view their own consultations
create policy "Patients can view own consultations"
  on public.consultations
  for select
  using (
    auth.uid() = (
      select user_id from public.patients where id = patient_id
    )
  );

-- Doctors can view all consultations
create policy "Doctors can view all consultations"
  on public.consultations
  for select
  using (authorize('doctor'));

-- Doctors can update consultations
create policy "Doctors can update consultations"
  on public.consultations
  for update
  using (authorize('doctor'));

-- Create updated_at trigger function
create or replace function public.handle_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

-- Apply updated_at trigger to consultations
create trigger set_updated_at
  before update on public.consultations
  for each row
  execute function public.handle_updated_at();

-- Create consent_records table (Phase 2 - LGPD compliance)
create table public.consent_records (
  id uuid default gen_random_uuid() primary key,
  user_id uuid references auth.users on delete cascade not null,
  consent_type text not null default 'health_data_collection',
  consented_at timestamptz default now() not null,
  withdrawn_at timestamptz,
  ip_address_hash text not null,
  version text not null,
  consent_text text not null,
  user_agent text,
  constraint valid_withdrawal check (withdrawn_at is null or withdrawn_at >= consented_at)
);

-- Enable RLS on consent_records
alter table public.consent_records enable row level security;

create policy "Users can view own consent records"
  on public.consent_records for select
  to authenticated
  using (auth.uid() = user_id);

create policy "Users can insert own consent records"
  on public.consent_records for insert
  to authenticated
  with check (auth.uid() = user_id);

create policy "Users can update own consent records"
  on public.consent_records for update
  to authenticated
  using (auth.uid() = user_id)
  with check (auth.uid() = user_id);

grant select, insert, update on table public.consent_records to authenticated;

-- Patients can create their own consultations
create policy "Patients can create own consultations"
  on public.consultations for insert
  to authenticated
  with check (
    auth.uid() = (select user_id from public.patients where id = patient_id)
  );

grant insert on table public.consultations to authenticated;

-- Performance indexes
create index idx_patients_user_id on public.patients(user_id);
create index idx_consultations_patient_id on public.consultations(patient_id);
create index idx_consent_user_id on public.consent_records(user_id);
create index idx_consent_user_active on public.consent_records(user_id, withdrawn_at)
  where withdrawn_at is null;

-- IMPORTANT: After running this script, you must manually enable the Custom Access Token Hook:
-- 1. Go to Supabase Dashboard -> Authentication -> Hooks
-- 2. Select "Custom Access Token Hook"
-- 3. Choose "public.custom_access_token_hook" from the dropdown
-- 4. Click Save
